# coding: utf-8

"""
    Azure Machine Learning - Text Analytics

    The Text Analytics API is a suite of text analytics web services built with Azure Machine Learning.   The API can be used to analyze unstructured text for tasks such as sentiment analysis, key phrase extraction and language detection.   No training data is needed to use this API; just bring your text data.   This API uses advanced natural language processing techniques to deliver best in class predictions.    Further documentation can be found in https://docs.microsoft.com/en-us/azure/cognitive-services/cognitive-services-text-analytics-quick-start

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class DefaultApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def detect_language(self, **kwargs):
        """
        The API returns the detected language and a numeric score between 0 and 1.               Scores close to 1 indicate 100% certainty that the identified language is true.               A total of 120 languages are supported.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.detect_language(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int number_of_languages_to_detect: Format - int32. (Optional) Number of languages to detect. Set to 1 by default.
        :param str subscription_key: subscription key in url
        :param str ocp_apim_subscription_key: subscription key in header
        :param BatchInputV2 batch_input_v2:
        :return: LanguageBatchResultV2
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.detect_language_with_http_info(**kwargs)
        else:
            (data) = self.detect_language_with_http_info(**kwargs)
            return data

    def detect_language_with_http_info(self, **kwargs):
        """
        The API returns the detected language and a numeric score between 0 and 1.               Scores close to 1 indicate 100% certainty that the identified language is true.               A total of 120 languages are supported.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.detect_language_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int number_of_languages_to_detect: Format - int32. (Optional) Number of languages to detect. Set to 1 by default.
        :param str subscription_key: subscription key in url
        :param str ocp_apim_subscription_key: subscription key in header
        :param BatchInputV2 batch_input_v2:
        :return: LanguageBatchResultV2
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['number_of_languages_to_detect', 'subscription_key', 'ocp_apim_subscription_key', 'batch_input_v2']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method detect_language" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        resource_path = '/languages'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'number_of_languages_to_detect' in params:
            query_params['numberOfLanguagesToDetect'] = params['number_of_languages_to_detect']
        if 'subscription_key' in params:
            query_params['subscription-key'] = params['subscription_key']

        header_params = {}
        if 'ocp_apim_subscription_key' in params:
            header_params['Ocp-Apim-Subscription-Key'] = params['ocp_apim_subscription_key']

        form_params = []
        local_var_files = {}

        body_params = None
        if 'batch_input_v2' in params:
            body_params = params['batch_input_v2']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'text/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='LanguageBatchResultV2',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def detect_topics(self, **kwargs):
        """
        The API returns the top detected topics for a list of submitted text documents.               A topic is identified with a key phrase, which can be one or more related words.               Use the URL parameters and stop word list to control which words or documents are filtered out.               You can also supply a list of topics to exclude from the response.               At least 100 text documents must be submitted, however it is designed to detect topics across hundreds to thousands of documents.               Note that one transaction is charged per text document submitted.               For best performance, limit each document to a short, human written text paragraph such as review, conversation or user feedback.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.detect_topics(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int min_documents_per_word: Format - int32. (optional) Words that occur in less than this many documents are ignored.               Use this parameter to help exclude rare document topics.              Omit to let the service choose appropriate value.
        :param int max_documents_per_word: Format - int32. (optional) Words that occur in more than this many documents are ignored.               Use this parameter to help exclude ubiquitous document topics.              Omit to let the service choose appropriate value.
        :param str subscription_key: subscription key in url
        :param str ocp_apim_subscription_key: subscription key in header
        :param TopicDetectionInputV2 topic_detection_input_v2:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.detect_topics_with_http_info(**kwargs)
        else:
            (data) = self.detect_topics_with_http_info(**kwargs)
            return data

    def detect_topics_with_http_info(self, **kwargs):
        """
        The API returns the top detected topics for a list of submitted text documents.               A topic is identified with a key phrase, which can be one or more related words.               Use the URL parameters and stop word list to control which words or documents are filtered out.               You can also supply a list of topics to exclude from the response.               At least 100 text documents must be submitted, however it is designed to detect topics across hundreds to thousands of documents.               Note that one transaction is charged per text document submitted.               For best performance, limit each document to a short, human written text paragraph such as review, conversation or user feedback.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.detect_topics_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int min_documents_per_word: Format - int32. (optional) Words that occur in less than this many documents are ignored.               Use this parameter to help exclude rare document topics.              Omit to let the service choose appropriate value.
        :param int max_documents_per_word: Format - int32. (optional) Words that occur in more than this many documents are ignored.               Use this parameter to help exclude ubiquitous document topics.              Omit to let the service choose appropriate value.
        :param str subscription_key: subscription key in url
        :param str ocp_apim_subscription_key: subscription key in header
        :param TopicDetectionInputV2 topic_detection_input_v2:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['min_documents_per_word', 'max_documents_per_word', 'subscription_key', 'ocp_apim_subscription_key', 'topic_detection_input_v2']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method detect_topics" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        resource_path = '/topics'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'min_documents_per_word' in params:
            query_params['minDocumentsPerWord'] = params['min_documents_per_word']
        if 'max_documents_per_word' in params:
            query_params['maxDocumentsPerWord'] = params['max_documents_per_word']
        if 'subscription_key' in params:
            query_params['subscription-key'] = params['subscription_key']

        header_params = {}
        if 'ocp_apim_subscription_key' in params:
            header_params['Ocp-Apim-Subscription-Key'] = params['ocp_apim_subscription_key']

        form_params = []
        local_var_files = {}

        body_params = None
        if 'topic_detection_input_v2' in params:
            body_params = params['topic_detection_input_v2']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'text/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def key_phrases(self, **kwargs):
        """
        The API returns a list of strings denoting the key talking points in the input text.               We employ techniques from Microsoft Office's sophisticated Natural Language Processing toolkit.               Currently, the following languages are supported: English, German, Spanish and Japanese.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.key_phrases(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_key: subscription key in url
        :param str ocp_apim_subscription_key: subscription key in header
        :param MultiLanguageBatchInputV2 multi_language_batch_input_v2:
        :return: KeyPhraseBatchResultV2
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.key_phrases_with_http_info(**kwargs)
        else:
            (data) = self.key_phrases_with_http_info(**kwargs)
            return data

    def key_phrases_with_http_info(self, **kwargs):
        """
        The API returns a list of strings denoting the key talking points in the input text.               We employ techniques from Microsoft Office's sophisticated Natural Language Processing toolkit.               Currently, the following languages are supported: English, German, Spanish and Japanese.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.key_phrases_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_key: subscription key in url
        :param str ocp_apim_subscription_key: subscription key in header
        :param MultiLanguageBatchInputV2 multi_language_batch_input_v2:
        :return: KeyPhraseBatchResultV2
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_key', 'ocp_apim_subscription_key', 'multi_language_batch_input_v2']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method key_phrases" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        resource_path = '/keyPhrases'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'subscription_key' in params:
            query_params['subscription-key'] = params['subscription_key']

        header_params = {}
        if 'ocp_apim_subscription_key' in params:
            header_params['Ocp-Apim-Subscription-Key'] = params['ocp_apim_subscription_key']

        form_params = []
        local_var_files = {}

        body_params = None
        if 'multi_language_batch_input_v2' in params:
            body_params = params['multi_language_batch_input_v2']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'text/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='KeyPhraseBatchResultV2',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def operation_status(self, operation_id, **kwargs):
        """
        Get the status of an operation submitted for processing. If the the operation has reached a 'Succeeded' state, will also return the result.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.operation_status(operation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str operation_id: A unique id for the submitted operation. (required)
        :param str subscription_key: subscription key in url
        :param str ocp_apim_subscription_key: subscription key in header
        :return: OperationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.operation_status_with_http_info(operation_id, **kwargs)
        else:
            (data) = self.operation_status_with_http_info(operation_id, **kwargs)
            return data

    def operation_status_with_http_info(self, operation_id, **kwargs):
        """
        Get the status of an operation submitted for processing. If the the operation has reached a 'Succeeded' state, will also return the result.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.operation_status_with_http_info(operation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str operation_id: A unique id for the submitted operation. (required)
        :param str subscription_key: subscription key in url
        :param str ocp_apim_subscription_key: subscription key in header
        :return: OperationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['operation_id', 'subscription_key', 'ocp_apim_subscription_key']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operation_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'operation_id' is set
        if ('operation_id' not in params) or (params['operation_id'] is None):
            raise ValueError("Missing the required parameter `operation_id` when calling `operation_status`")


        collection_formats = {}

        resource_path = '/operations/{operationId}'.replace('{format}', 'json')
        path_params = {}
        if 'operation_id' in params:
            path_params['operationId'] = params['operation_id']

        query_params = {}
        if 'subscription_key' in params:
            query_params['subscription-key'] = params['subscription_key']

        header_params = {}
        if 'ocp_apim_subscription_key' in params:
            header_params['Ocp-Apim-Subscription-Key'] = params['ocp_apim_subscription_key']

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='OperationResult',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def sentiment(self, **kwargs):
        """
        The API returns a numeric score between 0 and 1.               Scores close to 1 indicate positive sentiment, while scores close to 0 indicate negative sentiment.               Sentiment score is generated using classification techniques.               The input features to the classifier include n-grams, features generated from part-of-speech tags, and word embeddings.               Currently, the following languages are supported: English, Spanish, French, Portuguese.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.sentiment(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_key: subscription key in url
        :param str ocp_apim_subscription_key: subscription key in header
        :param MultiLanguageBatchInputV2 multi_language_batch_input_v2:
        :return: SentimentBatchResultV2
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.sentiment_with_http_info(**kwargs)
        else:
            (data) = self.sentiment_with_http_info(**kwargs)
            return data

    def sentiment_with_http_info(self, **kwargs):
        """
        The API returns a numeric score between 0 and 1.               Scores close to 1 indicate positive sentiment, while scores close to 0 indicate negative sentiment.               Sentiment score is generated using classification techniques.               The input features to the classifier include n-grams, features generated from part-of-speech tags, and word embeddings.               Currently, the following languages are supported: English, Spanish, French, Portuguese.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.sentiment_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_key: subscription key in url
        :param str ocp_apim_subscription_key: subscription key in header
        :param MultiLanguageBatchInputV2 multi_language_batch_input_v2:
        :return: SentimentBatchResultV2
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_key', 'ocp_apim_subscription_key', 'multi_language_batch_input_v2']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sentiment" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        resource_path = '/sentiment'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'subscription_key' in params:
            query_params['subscription-key'] = params['subscription_key']

        header_params = {}
        if 'ocp_apim_subscription_key' in params:
            header_params['Ocp-Apim-Subscription-Key'] = params['ocp_apim_subscription_key']

        form_params = []
        local_var_files = {}

        body_params = None
        if 'multi_language_batch_input_v2' in params:
            body_params = params['multi_language_batch_input_v2']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'text/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SentimentBatchResultV2',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
